#lang racket

(define (p) (p))
(define (test x y)
    (if (= x 0)
        0
        y
    )
)

(test 0 (p))

#|
    应用序是直接计算参数，形参计算完成后再代入过程。
    而正则序是全面展开，将符号代入过程中，展开到叶子节点后再从下往上归约。

    如果是正则序，那么进入 test 过程的就是 0 和 (p)，
    程序会判断传入的形参 x 就是 0，
    按照书中所说，(if <p> <e> <e>) 中，<p> 是谓词，会先计算这个。
    明显 (= x 0) 得到 #t，因为谓词结果为 #t，所以只看谓词后的第一个表达式。
    虽然第二个表达式为 y，也就是 (p)，但是并不会去计算它这个没有必要的值。
    从而直接返回 0。

    如果是应用序，就会先计算形参。但 (define (p) (p))，
    因此 dead loop。事实也是如此，跑不出来结果，只听见风扇狂转。
|#